# 今週のテーマ
変更に対処する

# 方針
リファクタリングを実際にどうやってやるのかを知りたい。
具体例がある箇所については実際にやってみることで、理解を深めていく

## 12.1 リファクタリングする理由
- ライブラリをシンプルにするため。
  - 2つ以上の場所に対して、同じ理由で同じ変更を加えている
  - 全く使われない抽象化されたコードをインラインにする（メソッドを削除して、呼び出し元でそのまま書く）
- 実行性能の改善
- ライブラリへの拡張ポイントを追加する

シンプルというのを具体的にどういうことかが書いてあったのは助かった。
ライブラリへの拡張ポイントを追加するというのは、いまいちピンとこない。具体的な例がほしいところ。

## 12.2 リファクタリングの進め方
### 重要なポイント
- リファクタリングに取り掛かる前にリファクタリング中に混入するバグを検知できる程度のテストを書いておくこと
- コツは1箇所ずつテストしていくこと
  - 必要な箇所は全部修正してから全部のテストを流すというプロセスが直感的ではあるが、これだとどこでエラーが起きているのか突き止めるのに時間がかかる
  - 自分も直感的にそのようにやっている。確かにFAILを探す手間はあるけど、検索すればすぐ見つかるし、そんなに手間だと感じてはいない
- 本当にこのリファクタリングが必要なのか？と問いかけること
  - 単に気に入らないという理由からやってはいけない。
  - 理由が明確に説明できることが重要。

ついつい気になって、もっとこうしたら良いんじゃないかなーと考えがち。
プログラマーなのだからそこは仕方がない。
ただ、今それをやるべきかを考える方がもっと重要。

## 12.3 よく使われる Ruby のリファクタリング技法
### メソッド抽出
- 抽出したメソッドにどんな処理をさせたいのか
- 同じことを繰り返している処理がすべて抽出され、かつ簡単に使える

例では`checkout`する箇所と`execute`する箇所が同じことを繰り返しているため、それらを抽出している。

### クラスの抽出
Addressクラスに抽出したことで以下の恩恵を得られた
- コンストラクタ引数が少なくなり、コードが読みやすくなった（可読性向上）
- format_labelメソッドに応答するオブジェクトを外から渡せるため、別のAddressクラスを使うことで、表記を変更可能になった（拡張できるようになった）
- 住所表記を変更したい場合に1箇所で済むようになった(DRY)

こういう恩恵が得られるのであれば、クラス抽出する価値がある


## 12.4 機能追加のためのリファクタリング

## 12.5 機能を適切に削除する

