# 今週のテーマ
エラーに対処する

# 方針
読みながら知らなかった部分や思ったことを率直に書いておくくらい。

実際に試したりするのは後回しにして、最後まで読み切る

時間測る 15m * 6 = 90m

時間をみつつ調整しながら進める

# 感想

## 5.1 戻り値によるエラー処理

### Rubyでのnilを返すか例外を返すかの原則

- 「もしレシーバーのデータ構成が参照時点と異なっていれば、値を取得できる」と期待される場合はnil

HashやArrayの添字に存在しない場所を指定した場合、nilが返る。

- 「レシーバーのデータ構成がどうあれ、データへの参照が必ず失敗する」場合は、例外を発生させる

Structでは、存在しないメンバーを参照すると例外が発生する


### メソッドの戻り値を使う必要がない場合の注意事項
メソッドの呼び出し側が戻り値を使う必要がない状況で、エラーの表現に戻り値を採用している場合には、特に用心が必要

戻り値を使う必要がない場合は戻り値を検査しないので、エラーになっているかどうかを見過ごしがち。

こういうケースでは一般に例外を発生させるほうがよい。

## 5.2 例外によるエラー処理

### 誤用耐性 (misuse resistance)の原則

API の設計にあたっては、APIを使いやすくすることだけでなく、APIを誤って使うのを難しくすることも考慮すべきである。

メソッド名に`?`が付くのはtrue, falseを返すメソッドであったり、`!`付きだと破壊的だったり、例外が出たりするなどの慣習があるので、それを守るべきということと理解

### フェイルオープン(fail-open)な設計とフェイルクローズド(fail-closed)な設計
失敗してもそのまま進めるか、失敗したら即座に終了するかの違いか？

trueかfalseを返す場合はフェイルオープン、例外を発生させる場合はフェイルクローズドみたいに言っているようにも見えるけど、それだと例外全部キャッチしたら一緒だよね？

いまいち理解できなかった

## 5.3 一時的なエラーを再試行する

### retry句
rescue句ではリトライするために`retry`句が使える

### リトライするときの待ち時間について
リトライするときの待ち時間を毎回同じにするのではなく、回数を重ねるごとに増やすという考え方は斬新だった。

回数を重ねるごとに少ない待機時間で成功するようになる現象ではなくなっていくはずなので、その分待機時間を増やして成功する確率を上げるということか？

ただ実際に使い所を考えてみても思い浮かばなかった。

### 直前に失敗しているなら呼び出さない方法
サーキットブレーカーと呼ばれるらしい。初めて知った。

失敗した回数とその時間を記録しておき、その時間中に何回も失敗していたら呼び出さない。

サーキットブレーカーを実装した gem の採用をということだったが、何があるんだろう？


## 5.4 例外クラス階層の設計

### 例外クラス設計の一般原則

- 「開発しているライブラリで例外を発生させるので あれば、独自の例外サブクラスを定義すべき」

ライブラリのユーザが他のライブラリの例外と区別できる

- 例外クラスを作るのは「エラーの種類に応じた個別の例外クラスを定義するのは、ユーザーがエラーの種類に応じた処理をおこないたい場合」に限る

そういう場面を想像できないなら、標準の例外クラスを使えばいい

ユーザの使い方を想像しながら例外クラスを作るということと理解した


## 時間
目標: 90m
5.1: 14m
5.2: 14m
5.3: 22m
5.4: 12m
まとめ: 26m
合計: 88m
