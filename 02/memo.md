# 今週のテーマ
役に立つ独自クラスを設計する

# 読んで理解したこと
## 2.1 いつ独自クラスを定義すべきか
独自クラスを定義する前に、何よりもまず考えるべきことは「本当に独自クラスを 定義する必要があるのだろうか?」と問いかけること  
独自クラスを作る、そのクラスの使い方を知る必要が出てくる分の負荷が高まる
組み込みクラスはRuby使いにとってはほぼほぼ使っているものであるため、負荷は少ない

独自クラスを定義するメリット
カプセル化することで、操作を限定できる
    サンプルコードでは、Stackを独自クラスにして、push pop以外を使えなくすることで、意図しない挙動ができないようにする
シンプルなメソッド呼び出しを提供できる
    サンプルコードではシンボルしか入らないStack、かつpop時に経過時間も返す実装を紹介、この場合独自のクラスがあれば、push時の例外や経過時間の計算をクラスの中に閉じ込めて呼び出しをシンプルにできる

これらのメリットが使い方を知る必要がある負荷とのトレードオフになる
（テストしやすさとかもあると思うから、それだけではなさそう）

また、このクラスがどれくらい使われるかという観点

筆者としては独自クラスを作って、呼び出す分、間接層ができて無駄にメモリを使ったり、実行時間が長くなることも考慮するように書いているが、そこは現代ではあまり気にしなくてもいいのでは？

チーム開発としては1回だけだとしても、シンプルに呼び出せて可読性が高まる方がメリットとしては大きいはず


## 2.2 SOLID 原則のトレードオフ
- SRP(Single-Responsibility Principle:単一責任の原則)
クラスは基本的には1つの目的を果たすべきものである
なぜ？ -> 複数の目的を持てばもつほど、さまざまなパラメータが必要になってくるため、使いにくい（簡単にnewできない）使い回しもできない
原則だからと適用してしまうと複雑性が増す。
書籍ではRubyのStringクラスを題材に、Stringクラスが文字列の追加や変更をそれぞれクラス化した場合に複雑になることを示している。
関連する複数の目的を単一のクラスで担う
文字列に関連する操作は関連する操作をそれぞれをクラス化するのではなく、文字列というクラスでひとまとめにする

このプログラムを部分的に置き換えたいかどうか
置き換えたい場合は置き換えたい部分をそれぞれクラスにしておく
特に置き換える必要がないのであれば、クラスを置き換えれるような構造にはせず、シンプルに保っておく
複雑さが必要になったときに対処した方がシンプルに保てる

- OCP(Open-Closed Principle:オープン・クローズドの原則)
クラスは拡張に対しては開かれていて(オープンである)、変更に対しては閉じている(クローズドである)こと
Rubyはオープンクラスなので、この原則は完全無視している
この原則をRubyでは当てはめようとするのは無駄な抵抗ということだが、
OCPは機能追加の際に既存クラスに手を加える必要なしで機能を拡張できる、機能変更の場合は関係するクラスだけを変更すればいい構造にしておくということを言いたかったはず。
ちょっと思っている感じと違う。

- LSP(Liskov Substitution Principle:リスコフの置換原則)
型 T のオブジェクトを使っている場所ならどこであっても、型 T のサブタイプで置き換えられるべき
この原則に従えば、使用しているオブジェクトをそのオブジェクトのどのサブクラスで置き換えても壊れない。
例では引数が異なっていたとしても、引数をオプショナル位置引数かキーワード引数として定義すれば従える例を出している。

- ISP(Interface Segregation Principle:インターフェイス分離の原則) 

- DIP(Dependency Inversion Principle:依存関係逆転の原則)
この5つのこと



# 試したこと、コードサンプル
実行速度の低下を検証

# 疑問、質問
