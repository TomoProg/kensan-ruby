# 今週のテーマ
メソッドと引数

# 方針
ざっと流し読んで、知らない部分を中心に読む

# 知らなかった部分

singleton_class -> selfと一緒？

> 「メソッド名の長さはメソッドが呼び出される回数に反比例する」 です。

使用頻度が多い場合は最短でわかる名前にする

使用頻度が高ければ毎回毎回長いメソッド名を書くよりも、短い方が使いやすいということか？

例えば、pを毎回print_inspectとか書いてたら確かに使いにくい

逆に1回しか呼ばないとかなら、長いメソッド名でも使う頻度は少ないから問題ない

> メソッド引数について最初に考えるべきことは、「そもそもメソッドに引数が必要 なのかどうか」です。

確かに。

これが原因でバグるのなら、ない方がマシ。

こういうそもそも論が書いてあるのがこの本では多い。

逆にめちゃくちゃ必要なら、メソッドでやろうとしている仕事が多すぎるのかもしれない

arityが-1？なんだそれ

> 一般原則として、引数のために個別のクラスを用意することに本当に意味があるのは、「引数クラスのインスタンスが単一のメソッドに渡されて完結することなく、複数のメソッドに渡されていく場合」か、「メソッドが引数クラスのインスタンスを戻 り値として返す場合」に限られます。

メソッド受け渡し用のクラスを定義する（dto）のは他のプロジェクトでざらにやってたように思うけど、アンチパターンなのか？

こんなメソッド定義もできるけど、ほとんど使わないだろう。
オプション引数を渡したい場合に後ろに追加するのではなく、前に追加しないといけない
```rb
def a(x=nil, y) 
end
```

こういう場合は確かに1つ目の引数がオプション引数でもよさそう
```rb
def build_select_sql(table_name=nil, column_name)
end
```


可変長引数は*だけでも使える
これは引数を無視したい場合

可変長引数で受け取るが配列で受け取るかは定義したメソッドの使い方による
配列で渡すことが多いのであれば、配列で受け取ればいい

Ruby2系のキーワード引数問題についての記述あり
可変朝引数を組み合わせた場合に、ハッシュで渡すとキーワード引数側に持って行かれてしまう

**nilを使うことでキーワード引数を無視することが可能

block.arityでブロックの引数の数を取得できる
ブロックは一つしか渡せないため、一回挙動を決めてしまうと容易に変更ができない。慎重に考えるべき

一般的に、ライブラリのパブリックメソッドは
「メジャーアップデートのタイミングでのみ変更されるべき」とされています。
→へぇー。確かに急にpublicのメソッドのインターフェース変わったら使えなくなって困る

基本的にprivate使えってことだよな
protectedは「ライブラリ内部でのみの利用で、かつメソッドの呼び出し元が同じクラスの別メソッドであり、しかも send を使うオーバーヘッドを避けたい」
ときとのことだけど、業務アプリを作る側からすると、sendのオーバーヘッドを避けたいというときはそれほどないと思うし、基本的にprivateか
protectedはレシーバが自身と同じクラスなら呼び出せる

method_missingをオーバーライドすることで、メッセージを表示して段階的に可視性を変更する
定数の場合はconst_missing

deprecate_public という gem を使えば、非推奨のメソッドを使ったときに警告を出す処理を簡単に実装可能

...を使うことで、引数をすべて別のメソッドに渡すことができる








# 読んで理解したこと

## 3.1 ローカル変数:Ruby で大活躍の変数
ローカル変数を使うことで実行性能の向上につながるようなことが書いてある。  

何度も呼び出さずにローカル変数にキャッシュしてそれを使いまわせばいいということ。

スコープゲートや命名についても記載がある。

- attr_readerによるアクセスを何回も行わず、一度ローカル変数にキャッシュしてそれを使う

ここまでパフォーマンス必要なときはほぼないのでは？

- procはクロージャなので、ブロックの外側の変数をブロック内に閉じ込められる

ブロック内で何度もメソッドを呼ぶのではなく、ブロックの外でローカル変数にキャッシュしておく
```rb
class Sample
  def to_proc
    # こう書いてしまうと重い処理が毎回呼ばれてしまう
    #proc {|v| v + heavy_method }

    # こう書けば一回だけ重い処理が呼ばれるため、早く済む
    a = heavy_method
    proc {|v| v + a }
  end

  def heavy_method
    # 重い処理
    sleep 3
    10
  end
end

p [1, 2, 3].map(&Sample.new) #=> [11, 12, 13]

```

- 定数をローカル変数に受け取ることでわずかに計算量があがる

考えたことなかった。認知負荷が増えるので、ほぼ使わないと思う

- スコープゲートについて

def、class、moduleキーワードのたびにスコープが変わる（スコープゲート）

define_method、Class.new、Module.newはスコープゲートを作らない

- 命名について

ローカル変数命名の一般原則は、「変数名の長さを、その変数のスコープの広さに比例させる」というものです。 

なるほどと感じた。スコープが小さければ短い変数名でも理解に苦しまないけど、長いと苦しむ


## 3.2 インスタンス変数を活用する
ざっと流し読み

インスタンス変数でキャッシュしておくような話はわかったが、それ以外はなんかピンとこなかった。

## 3.3 定数も単なる変数である
private_constantで定数を隠すことができるのは知らなかった。

## 3.4 クラス変数を置き換える
TODO

# 試したこと、コードサンプル
特になし

# 疑問、質問
