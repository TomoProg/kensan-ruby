# 今週のテーマ
メソッドと引数

# 方針
ざっと流し読んで、知らない部分を中心に読む

# 知らなかった部分

- 「メソッド名の長さはメソッドが呼び出される回数に反比例する」 です。

使用頻度が多い場合は最短でわかる名前にする

使用頻度が高ければ毎回毎回長いメソッド名を書くよりも、短い方が使いやすいということか？

例えば、pを毎回print_inspectとか書いてたら確かに使いにくい

逆に1回しか呼ばないとかなら、長いメソッド名でも使う頻度は少ないから問題ない

- メソッド引数について最初に考えるべきことは、「そもそもメソッドに引数が必要 なのかどうか」です。

これが原因でバグるのなら、ない方がマシ。

逆にめちゃくちゃ必要なら、メソッドでやろうとしている仕事が多すぎるのかもしれない

- arityが-1

Method#arity 可変長引数は -1 を返す

- 一般原則として、引数のために個別のクラスを用意することに本当に意味があるのは、「引数クラスのインスタンスが単一のメソッドに渡されて完結することなく、複数のメソッドに渡されていく場合」か、「メソッドが引数クラスのインスタンスを戻 り値として返す場合」に限られます。

メソッド受け渡し用のクラスを定義する（dto）のは他のプロジェクトでざらにやってたように思うけど、アンチパターンなのか？

- オプション引数を前に定義できる

こんなメソッド定義もできる

ただ、ほとんど使わなさそう

オプション引数を渡したい場合に後ろに追加するのではなく、前に追加しないといけない
```rb
def a(x=nil, y) 
end
```

ただし、こういう場合は確かに1つ目の引数がオプション引数でも違和感がない
```rb
def build_select_sql(table_name=nil, column_name)
  "#{table_name}.#{column_name}"
end
```

- 可変長引数は*だけでも使える

これは引数を無視したい場合に使える

- Ruby2系のキーワード引数問題
Ruby2系のキーワード引数問題についての記述あり
可変長引数を組み合わせた場合に、ハッシュで渡すとキーワード引数側に持って行かれてしまう

- **nilを使うことでキーワード引数を無視することが可能

- block.arityでブロックの引数の数を取得できる

ブロックは一つしか渡せないため、引数の数で挙動を変えたいというときに使える
一回挙動を決めてしまうと容易に変更ができない。慎重に考えるべき

- 一般的に、ライブラリのパブリックメソッドは「メジャーアップデートのタイミングでのみ変更されるべき」とされています。

確かに急にpublicのメソッドのインターフェース変わったら使えなくなって困る

protectedは「ライブラリ内部でのみの利用で、かつメソッドの呼び出し元が同じクラスの別メソッドであり、しかも send を使うオーバーヘッドを避けたい」ときとのことだけど、業務アプリを作る側からすると、sendのオーバーヘッドを避けたいというときはそれほどないと思うし、基本的にprivateか

protectedはレシーバが自身と同じクラスなら呼び出せる

- 段階的に可視性を変更するには

method_missing をオーバーライドすることで、メッセージを表示して段階的に可視性を変更する

定数の場合は const_missing をオーバーライドする

- deprecate_public という gem がある

非推奨のメソッドを使ったときに警告を出す処理を簡単に実装可能

- 引数をすべて別のメソッドに渡す

...を使うとできる

