# 今週のテーマ
きちんとコードが動くことをテストする

# 方針
思ったことを率直に書いておくくらい。  
理解できない部分で実際にコードを書いてみれるなら書いてみる

## 11.1 なぜそんなにも Ruby ではテストが重要なのか
Rubyでは動的な型システムを採用しているため、型チェックが行われないが故にバグが出てくる。  
↓  
これは確かに。Rubyだけじゃなくて動的型付けの言語だとそうなる。想定外の型を渡されることでバグが出る。  
当たり前といえば当たり前だけど、これを止める手段がない。  
メソッドコメントなどで対処するしかないか。

動かしてみないと構文エラーかどうかすらわからない。  
↓  
実行したら構文エラーかどうかはわかるから、cオプションも使ったことがない。  
それほど問題じゃない。  

> 大事なのはオブジェクトがどんなメソッドに応答できるかです。 

これな。  
型付きの言語のようなインターフェースの機能はないけど、実質これを定義しているようなもの。  

## 11.2 さまざまなテスト手法
- 手動テスト
- 開発後テスト（TAD:Test After Development）  
  初めて聞いた。実装を先にやってしまってからテストを書く
- テスト駆動開発(TDD:Test-Driven Development)  
  テストを先に書き、そのテストを通すように実装を行う
- ビヘイビア駆動開発(BDD:Behavior-Driven Development)  
  英語のような形式でテストを書き、それをパスするようにコードを書く  
  結局テストを書いて、それを通すように書くのならTDDと一緒だが、書き方が違う

### TAD
- TADでは実装が先にくるため、シンプルで実装しやすい方法になりやすい
- 一方でテストが難しいコードになる可能性がある

### TDD、BDD
- テストしやすいコードになる
- 一方で実装が難しく、ユーザが求めているインターフェースにならない恐れがある

どちらも一長一短。  
プログラマーが意識してテスト、プロダクトコードを書く必要がある。  

## 11.3 テストをどこまで複雑にするか

> テストは、ライブラリのコードにおける問題を回避し、デバッグを助けるように設計されるものです。  
> ところが、テストの抽象化が進めば進むほど、ライブラリのコードよりもテストのコードをデバッグする機会が増えてしまいかねません。  
> ある程度以上にテストの抽象化を進めてしまうと、テストに失敗しても、その結果を信頼できなくなります。  
> バグの原因がライブラリにあるのか、それともテスト自体にあるのかがわからないからです。これはまずい状況です。  

肝に命じたい。  
プロダクトコードだと良いこととされていることが、テストコードだと悪いことであることを理解しておく必要がある。  
ALのテストコードも一部こんなことになってたはず。

## 11.4 さまざまなレベルでのテスト
- ユニットテスト  
オブジェクトのメソッドが依存するものをすべてモックやスタブに置き換えてテストする  

- モデルテスト  
初めて聞いた。  
ユニットテストよりも上のレイヤーでモックやスタブには置き換えずにメソッドをそのままテストする

ユニットテストにしておきたい場合というのは実行速度が求められる場合に限られる。  
それ以外はモデルテストを使った方が、壊れているのを検出し損ねるリスクが低い。

## 11.5 カバレッジ 100% に意味はない
カバレッジを測定することでプロダクトコードがどれくらいテストされているのかがわかる  

カバレッジには以下のものがある
- 行カバレッジ
  - どの行が実行されたか
- ブランチカバレッジ
  - 条件分岐を網羅しているか
- メソッドカバレッジ
  - メソッドが呼ばれたかどうか

100%を目指すことを目標にしてしまうと、行やメソッドをただ呼び出すだけでよく、検証が正しいかどうかは考えなくてもいい。  
100%を目指すよりも、テストで検証するべき項目が正しく検証できているかが大切。
あまりカバレッジを意識したことはなかったが、100%に意味ないという理由が知れた。  
